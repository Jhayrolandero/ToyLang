// Demonstrate parallel execution in Chan language

// Helper function to simulate work
let sleep = (ms) => {
    // We can't directly implement sleep in our language,
    // but in a real implementation this would pause execution
    print("Sleeping for " + ms + " milliseconds...");
};

// Sequential execution for comparison
print("Starting sequential execution:");
print("Task 1 starting");
sleep(1000);
print("Task 1 completed");
print("Task 2 starting");
sleep(500);
print("Task 2 completed");
print("Sequential execution finished");

// Parallel execution
print("\nStarting parallel execution:");

parallel {
    print("Parallel task 1 starting");
    sleep(1000);
    print("Parallel task 1 completed");
}

parallel {
    print("Parallel task 2 starting");
    sleep(500);
    print("Parallel task 2 completed");
}

print("Parallel execution demonstration finished");

// More complex example
let counter = 0;

// These will run in parallel and may complete in any order
parallel {
    print("Incrementing counter");
    counter = counter + 1;
    print("Counter now: " + counter);
}

parallel {
    print("Incrementing counter again");
    counter = counter + 1;
    print("Counter now: " + counter);
}

print("Final counter value: " + counter);

// Comprehensive parallel execution demo

// Create a utility function to format time
let formatTime = (seconds) => {
    return Math.round(seconds * 1000) / 1000;
};

// Function to demonstrate sequential vs parallel execution
let runDemo = () => {
    // Sequential execution
    print("=== SEQUENTIAL EXECUTION ===");
    let start = timestamp();
    
    // Task 1: Long computation (simulated with sleep)
    print("Starting Task 1 (2 second task)");
    sleep(2000);
    print("Completed Task 1 after " + formatTime(timestamp() - start) + " seconds");
    
    // Task 2: Medium computation
    print("Starting Task 2 (1 second task)");
    sleep(1000);
    print("Completed Task 2 after " + formatTime(timestamp() - start) + " seconds");
    
    // Task 3: Short computation
    print("Starting Task 3 (0.5 second task)");
    sleep(500);
    print("Completed Task 3 after " + formatTime(timestamp() - start) + " seconds");
    
    let end = timestamp();
    print("Total sequential execution time: " + formatTime(end - start) + " seconds");
    
    // Pause between tests
    print("\n");
    
    // Parallel execution
    print("=== PARALLEL EXECUTION ===");
    start = timestamp();
    
    // Launch all tasks in parallel
    parallel {
        print("Starting Parallel Task 1 (2 second task)");
        sleep(2000);
        print("Completed Parallel Task 1 after " + formatTime(timestamp() - start) + " seconds");
    }
    
    parallel {
        print("Starting Parallel Task 2 (1 second task)");
        sleep(1000);
        print("Completed Parallel Task 2 after " + formatTime(timestamp() - start) + " seconds");
    }
    
    parallel {
        print("Starting Parallel Task 3 (0.5 second task)");
        sleep(500);
        print("Completed Parallel Task 3 after " + formatTime(timestamp() - start) + " seconds");
    }
    
    // Sleep to ensure all parallel tasks complete before checking time
    // In real code, you would implement proper synchronization
    sleep(2100);
    
    end = timestamp();
    print("Total parallel execution time: " + formatTime(end - start) + " seconds");
    print("(Notice that parallel execution takes only as long as the longest task!)");
};

// Run the demo
runDemo(); 